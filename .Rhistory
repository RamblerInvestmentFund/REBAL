portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MAY NEED THIS FOR ERRORS BELOW
######################STEP THREE: CONSTRUCTION #########################################
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
'''
Author: 7Leven
Purpose: Portfolio Optimization & Risk Analytics
sevRoll
'''
library(timeSeries)
library(fPortfolio)
library(quantmod)
library(caTools)
library(dplyr)
library(PerformanceAnalytics)
library(ggplot2)
library(tidyr)
######################      MISC: CONFIG       #########################################
start_date <- "2006-01-01" #Format year-mo-da
end_date <- substr(Sys.time(), 0, 10) #gets current date
tar_return <- .1 #target return - 10%
tar_risk <- .05 #target risk variance - 5%
alp <- .01 #alpha
risk_free <- .0225 #risk free rate, treasury
risk_aversion <- 1 #risk aversion coefficient
tickers <- c("VOX", "VCR",
"VDC", "VDE",
"VFH", "VHT",
"VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:8)]=.05",
"maxW[c(1:8)]=.2")
######################STEP ONE: Wrangling Data #########################################
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MAY NEED THIS FOR ERRORS BELOW
######################STEP THREE: CONSTRUCTION #########################################
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
View(portfolio.returns)
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
#portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YO
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
windows
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MAY NEED THIS FOR ERRORS BELOW
##################
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
tickers <- c("VOX", "VCR",
"VDC", "VDE",
"VFH", "VHT",
"VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:11)]=.05",
"maxW[c(1:11)]=.2")
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MA
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
tickers <- c("VOX", "VCR",
"VDC", "VDE",
#             "VFH", "VHT",
#             "VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:7)]=.05",
"maxW[c(1:7)]=.2")
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns)
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
tickers <- c("VOX", "VCR",
"VDC", "VDE",
"VFH", "VHT",
"VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:11)]=.05",
"maxW[c(1:11)]=.2")
start_date <- "2010-01-01" #Format year-mo-da
end_date <- substr(Sys.time(), 0, 10) #gets current date
tar_return <- .1 #target return - 10%
tar_risk <- .05 #target risk variance - 5%
alp <- .01 #alpha
risk_free <- .0225 #risk free rate, treasury
risk_aversion <- 1 #risk aversion coefficient
tickers <- c("VOX", "VCR",
"VDC", "VDE",
"VFH", "VHT",
"VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:11)]=.05",
"maxW[c(1:11)]=.2")
######################STEP ONE: Wrangling Data #########################################
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MAY NEED THIS FOR ERRORS BELOW
######################STEP THREE: CONSTRUCTION #########################################
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
start_date <- "2010-01-01" #Format year-mo-da
end_date <- substr(Sys.time(), 0, 10) #gets current date
tar_return <- .1 #target return - 10%
tar_risk <- .05 #target risk variance - 5%
alp <- .01 #alpha
risk_free <- .0225 #risk free rate, treasury
risk_aversion <- 1 #risk aversion coefficient
tickers <- c("VOX", "VCR",
"VDC", "VDE",
"VFH", "VHT",
"VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:11)]=.05",
"maxW[c(1:11)]=.2")
######################STEP ONE: Wrangling Data #########################################
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MAY NEED THIS FOR ERRORS BELOW
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
library(timeSeries)
library(fPortfolio)
library(quantmod)
library(caTools)
library(dplyr)
library(PerformanceAnalytics)
library(ggplot2)
library(tidyr)
library(timeSeries)
library(fPortfolio)
library(quantmod)
library(caTools)
library(dplyr)
library(PerformanceAnalytics)
library(ggplot2)
library(tidyr)
start_date <- "2010-01-01" #Format year-mo-da
end_date <- substr(Sys.time(), 0, 10) #gets current date
tar_return <- .1 #target return - 10%
tar_risk <- .05 #target risk variance - 5%
alp <- .01 #alpha
risk_free <- .0225 #risk free rate, treasury
risk_aversion <- 1 #risk aversion coefficient
tickers <- c("VOX", "VCR",
"VDC", "VDE",
"VFH", "VHT",
"VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:11)]=.05",
"maxW[c(1:11)]=.2")
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns)
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
?getSymbols
weights
rolled.frontier
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
start_date <- "2015-01-01" #Format year-mo-da
end_date <- substr(Sys.time(), 0, 10) #gets current date
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MAY NEED THIS FOR ERRORS BELOW
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
rolled.frontier
start_date <- "2000-01-01" #Format year-mo-da
end_date <- substr(Sys.time(), 0, 10) #gets current date
tar_return <- .1 #target return - 10%
tar_risk <- .05 #target risk variance - 5%
alp <- .01 #alpha
risk_free <- .0225 #risk free rate, treasury
risk_aversion <- 1 #risk aversion coefficient
tickers <- c("VOX", "VCR",
"VDC", "VDE",
"VFH", "VHT",
"VIS", "VGT",
"VAW", "VNQ",
"VPU")
weights <- c("minW[c(1:11)]=.05",
"maxW[c(1:11)]=.2")
portfolio <- NULL #normally you dont need to declare variables null before using them
portfolio.div <- NULL # R's scope requirements make this easier when binding within a loop..
for(ticker in tickers){ #looping through portfolio, gathering returns & dividends
portfolio <- cbind(portfolio, getSymbols(ticker, from = start_date, to = end_date, auto.assign =  FALSE)[,6])
portfolio.div <- cbind(portfolio.div, getDividends(ticker,from = start_date, to = end_date, auto.assign =  FALSE))
}
colnames(portfolio) <- tickers #making the dataframes look pretty
names(portfolio.div) <- gsub(".div", "", names(portfolio.div))
portfolio.yield <- colSums(portfolio.div, na.rm = TRUE) #calculating dividend yield
portfolio.yield <- as.data.frame(t(portfolio.yield)) #converting to row
portfolio.yield$MINT <- NULL #removing cash yield - placeholde
for(ticker in names(portfolio.yield)){ #adding dividends into total return.
portfolio[nrow(portfolio), ticker] <- as.double(portfolio[nrow(portfolio), ticker]) + as.double(portfolio.yield[ticker])
}
portfolio.returns <- CalculateReturns(portfolio) #calculating returns with dividends added
portfolio <- na.omit(portfolio) #removing empty/NA values
portfolio.returns <- as.timeSeries(portfolio.returns) #converting to time series, required below
meanReturns <- colMeans(portfolio.returns) #calculating mean return for each ticker
covMat <- cov(portfolio.returns) #covariance matrix
portfolio.returns <- na.omit(portfolio.returns) # YOU MAY NEED THIS FOR ERRORS BELOW
portSpec <- portfolioSpec( #this is where the risk aversion and other parameters are input
model = list(type = "MV", optimize = "minRisk",
estimator = "covEstimator", tailRisk = list(),
params = list(alpha = alp, a = risk_aversion)),
portfolio = list(weights = NULL, targetReturn = tar_return,
targetRisk = tar_risk, riskFreeRate = risk_free,
status = 0),
optim = list(solver = "solveRquadprog", objective = NULL,
params = list(meq = 2), control = list(), trace = FALSE))
windows = rollingWindows(portfolio.returns, period = "6m", by = "1m")
frontier <- portfolioFrontier(portfolio.returns, portSpec, constraints = weights)
rolled.frontier <- rollingPortfolioFrontier(portfolio.returns, portSpec,
constraints = weights, from = windows$from,
to = windows$to)
install.packages(vignette )
install.packages(vignette)
install.packages("vignette")
library(vignette)
library("vignette")
library(dplyr)
?fread
test <- function(data, weights=c()){print(data)}
test(1)
source('~/RIF/GUI/read_settings.R')
source('~/RIF/GUI/v1/SETTINGS_v1.R')
